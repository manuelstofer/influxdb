// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: functions.gen.go.tmpl

package influxql

// FloatPointAggregator aggregates points to produce a single point.
type FloatPointAggregator interface {
	Aggregate(points ...*FloatPoint)
}

// FloatPointEmitter produces a single point from an aggregate.
type FloatPointEmitter interface {
	Emit() []FloatPoint
}

// FloatReduceFunc is the function called by a FloatPoint reducer.
type FloatReduceFunc func(prev *FloatPoint, curr *FloatPoint) (t int64, v float64, aux []interface{})

type FloatFuncReducer struct {
	prev *FloatPoint
	fn   FloatReduceFunc
}

func NewFloatFuncReducer(fn FloatReduceFunc) *FloatFuncReducer {
	return &FloatFuncReducer{fn: fn}
}

func (r *FloatFuncReducer) Aggregate(points ...*FloatPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &FloatPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *FloatFuncReducer) Emit() []FloatPoint {
	return []FloatPoint{*r.prev}
}

// FloatReduceSliceFunc is the function called by a FloatPoint reducer.
type FloatReduceSliceFunc func(a []FloatPoint) []FloatPoint

type FloatSliceFuncReducer struct {
	points []FloatPoint
	fn     FloatReduceSliceFunc
}

func NewFloatSliceFuncReducer(fn FloatReduceSliceFunc) *FloatSliceFuncReducer {
	return &FloatSliceFuncReducer{fn: fn}
}

func (r *FloatSliceFuncReducer) Aggregate(points ...*FloatPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]FloatPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *FloatSliceFuncReducer) Emit() []FloatPoint {
	return r.fn(r.points)
}

// FloatReduceIntegerFunc is the function called by a FloatPoint reducer.
type FloatReduceIntegerFunc func(prev *IntegerPoint, curr *FloatPoint) (t int64, v int64, aux []interface{})

type FloatFuncIntegerReducer struct {
	prev *IntegerPoint
	fn   FloatReduceIntegerFunc
}

func NewFloatFuncIntegerReducer(fn FloatReduceIntegerFunc) *FloatFuncIntegerReducer {
	return &FloatFuncIntegerReducer{fn: fn}
}

func (r *FloatFuncIntegerReducer) Aggregate(points ...*FloatPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &IntegerPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *FloatFuncIntegerReducer) Emit() []IntegerPoint {
	return []IntegerPoint{*r.prev}
}

// FloatReduceIntegerSliceFunc is the function called by a FloatPoint reducer.
type FloatReduceIntegerSliceFunc func(a []FloatPoint) []IntegerPoint

type FloatSliceFuncIntegerReducer struct {
	points []FloatPoint
	fn     FloatReduceIntegerSliceFunc
}

func NewFloatSliceFuncIntegerReducer(fn FloatReduceIntegerSliceFunc) *FloatSliceFuncIntegerReducer {
	return &FloatSliceFuncIntegerReducer{fn: fn}
}

func (r *FloatSliceFuncIntegerReducer) Aggregate(points ...*FloatPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]FloatPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *FloatSliceFuncIntegerReducer) Emit() []IntegerPoint {
	return r.fn(r.points)
}

// FloatReduceStringFunc is the function called by a FloatPoint reducer.
type FloatReduceStringFunc func(prev *StringPoint, curr *FloatPoint) (t int64, v string, aux []interface{})

type FloatFuncStringReducer struct {
	prev *StringPoint
	fn   FloatReduceStringFunc
}

func NewFloatFuncStringReducer(fn FloatReduceStringFunc) *FloatFuncStringReducer {
	return &FloatFuncStringReducer{fn: fn}
}

func (r *FloatFuncStringReducer) Aggregate(points ...*FloatPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &StringPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *FloatFuncStringReducer) Emit() []StringPoint {
	return []StringPoint{*r.prev}
}

// FloatReduceStringSliceFunc is the function called by a FloatPoint reducer.
type FloatReduceStringSliceFunc func(a []FloatPoint) []StringPoint

type FloatSliceFuncStringReducer struct {
	points []FloatPoint
	fn     FloatReduceStringSliceFunc
}

func NewFloatSliceFuncStringReducer(fn FloatReduceStringSliceFunc) *FloatSliceFuncStringReducer {
	return &FloatSliceFuncStringReducer{fn: fn}
}

func (r *FloatSliceFuncStringReducer) Aggregate(points ...*FloatPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]FloatPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *FloatSliceFuncStringReducer) Emit() []StringPoint {
	return r.fn(r.points)
}

// FloatReduceBooleanFunc is the function called by a FloatPoint reducer.
type FloatReduceBooleanFunc func(prev *BooleanPoint, curr *FloatPoint) (t int64, v bool, aux []interface{})

type FloatFuncBooleanReducer struct {
	prev *BooleanPoint
	fn   FloatReduceBooleanFunc
}

func NewFloatFuncBooleanReducer(fn FloatReduceBooleanFunc) *FloatFuncBooleanReducer {
	return &FloatFuncBooleanReducer{fn: fn}
}

func (r *FloatFuncBooleanReducer) Aggregate(points ...*FloatPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &BooleanPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *FloatFuncBooleanReducer) Emit() []BooleanPoint {
	return []BooleanPoint{*r.prev}
}

// FloatReduceBooleanSliceFunc is the function called by a FloatPoint reducer.
type FloatReduceBooleanSliceFunc func(a []FloatPoint) []BooleanPoint

type FloatSliceFuncBooleanReducer struct {
	points []FloatPoint
	fn     FloatReduceBooleanSliceFunc
}

func NewFloatSliceFuncBooleanReducer(fn FloatReduceBooleanSliceFunc) *FloatSliceFuncBooleanReducer {
	return &FloatSliceFuncBooleanReducer{fn: fn}
}

func (r *FloatSliceFuncBooleanReducer) Aggregate(points ...*FloatPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]FloatPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *FloatSliceFuncBooleanReducer) Emit() []BooleanPoint {
	return r.fn(r.points)
}

// IntegerPointAggregator aggregates points to produce a single point.
type IntegerPointAggregator interface {
	Aggregate(points ...*IntegerPoint)
}

// IntegerPointEmitter produces a single point from an aggregate.
type IntegerPointEmitter interface {
	Emit() []IntegerPoint
}

// IntegerReduceFloatFunc is the function called by a IntegerPoint reducer.
type IntegerReduceFloatFunc func(prev *FloatPoint, curr *IntegerPoint) (t int64, v float64, aux []interface{})

type IntegerFuncFloatReducer struct {
	prev *FloatPoint
	fn   IntegerReduceFloatFunc
}

func NewIntegerFuncFloatReducer(fn IntegerReduceFloatFunc) *IntegerFuncFloatReducer {
	return &IntegerFuncFloatReducer{fn: fn}
}

func (r *IntegerFuncFloatReducer) Aggregate(points ...*IntegerPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &FloatPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *IntegerFuncFloatReducer) Emit() []FloatPoint {
	return []FloatPoint{*r.prev}
}

// IntegerReduceFloatSliceFunc is the function called by a IntegerPoint reducer.
type IntegerReduceFloatSliceFunc func(a []IntegerPoint) []FloatPoint

type IntegerSliceFuncFloatReducer struct {
	points []IntegerPoint
	fn     IntegerReduceFloatSliceFunc
}

func NewIntegerSliceFuncFloatReducer(fn IntegerReduceFloatSliceFunc) *IntegerSliceFuncFloatReducer {
	return &IntegerSliceFuncFloatReducer{fn: fn}
}

func (r *IntegerSliceFuncFloatReducer) Aggregate(points ...*IntegerPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]IntegerPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *IntegerSliceFuncFloatReducer) Emit() []FloatPoint {
	return r.fn(r.points)
}

// IntegerReduceFunc is the function called by a IntegerPoint reducer.
type IntegerReduceFunc func(prev *IntegerPoint, curr *IntegerPoint) (t int64, v int64, aux []interface{})

type IntegerFuncReducer struct {
	prev *IntegerPoint
	fn   IntegerReduceFunc
}

func NewIntegerFuncReducer(fn IntegerReduceFunc) *IntegerFuncReducer {
	return &IntegerFuncReducer{fn: fn}
}

func (r *IntegerFuncReducer) Aggregate(points ...*IntegerPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &IntegerPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *IntegerFuncReducer) Emit() []IntegerPoint {
	return []IntegerPoint{*r.prev}
}

// IntegerReduceSliceFunc is the function called by a IntegerPoint reducer.
type IntegerReduceSliceFunc func(a []IntegerPoint) []IntegerPoint

type IntegerSliceFuncReducer struct {
	points []IntegerPoint
	fn     IntegerReduceSliceFunc
}

func NewIntegerSliceFuncReducer(fn IntegerReduceSliceFunc) *IntegerSliceFuncReducer {
	return &IntegerSliceFuncReducer{fn: fn}
}

func (r *IntegerSliceFuncReducer) Aggregate(points ...*IntegerPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]IntegerPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *IntegerSliceFuncReducer) Emit() []IntegerPoint {
	return r.fn(r.points)
}

// IntegerReduceStringFunc is the function called by a IntegerPoint reducer.
type IntegerReduceStringFunc func(prev *StringPoint, curr *IntegerPoint) (t int64, v string, aux []interface{})

type IntegerFuncStringReducer struct {
	prev *StringPoint
	fn   IntegerReduceStringFunc
}

func NewIntegerFuncStringReducer(fn IntegerReduceStringFunc) *IntegerFuncStringReducer {
	return &IntegerFuncStringReducer{fn: fn}
}

func (r *IntegerFuncStringReducer) Aggregate(points ...*IntegerPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &StringPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *IntegerFuncStringReducer) Emit() []StringPoint {
	return []StringPoint{*r.prev}
}

// IntegerReduceStringSliceFunc is the function called by a IntegerPoint reducer.
type IntegerReduceStringSliceFunc func(a []IntegerPoint) []StringPoint

type IntegerSliceFuncStringReducer struct {
	points []IntegerPoint
	fn     IntegerReduceStringSliceFunc
}

func NewIntegerSliceFuncStringReducer(fn IntegerReduceStringSliceFunc) *IntegerSliceFuncStringReducer {
	return &IntegerSliceFuncStringReducer{fn: fn}
}

func (r *IntegerSliceFuncStringReducer) Aggregate(points ...*IntegerPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]IntegerPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *IntegerSliceFuncStringReducer) Emit() []StringPoint {
	return r.fn(r.points)
}

// IntegerReduceBooleanFunc is the function called by a IntegerPoint reducer.
type IntegerReduceBooleanFunc func(prev *BooleanPoint, curr *IntegerPoint) (t int64, v bool, aux []interface{})

type IntegerFuncBooleanReducer struct {
	prev *BooleanPoint
	fn   IntegerReduceBooleanFunc
}

func NewIntegerFuncBooleanReducer(fn IntegerReduceBooleanFunc) *IntegerFuncBooleanReducer {
	return &IntegerFuncBooleanReducer{fn: fn}
}

func (r *IntegerFuncBooleanReducer) Aggregate(points ...*IntegerPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &BooleanPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *IntegerFuncBooleanReducer) Emit() []BooleanPoint {
	return []BooleanPoint{*r.prev}
}

// IntegerReduceBooleanSliceFunc is the function called by a IntegerPoint reducer.
type IntegerReduceBooleanSliceFunc func(a []IntegerPoint) []BooleanPoint

type IntegerSliceFuncBooleanReducer struct {
	points []IntegerPoint
	fn     IntegerReduceBooleanSliceFunc
}

func NewIntegerSliceFuncBooleanReducer(fn IntegerReduceBooleanSliceFunc) *IntegerSliceFuncBooleanReducer {
	return &IntegerSliceFuncBooleanReducer{fn: fn}
}

func (r *IntegerSliceFuncBooleanReducer) Aggregate(points ...*IntegerPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]IntegerPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *IntegerSliceFuncBooleanReducer) Emit() []BooleanPoint {
	return r.fn(r.points)
}

// StringPointAggregator aggregates points to produce a single point.
type StringPointAggregator interface {
	Aggregate(points ...*StringPoint)
}

// StringPointEmitter produces a single point from an aggregate.
type StringPointEmitter interface {
	Emit() []StringPoint
}

// StringReduceFloatFunc is the function called by a StringPoint reducer.
type StringReduceFloatFunc func(prev *FloatPoint, curr *StringPoint) (t int64, v float64, aux []interface{})

type StringFuncFloatReducer struct {
	prev *FloatPoint
	fn   StringReduceFloatFunc
}

func NewStringFuncFloatReducer(fn StringReduceFloatFunc) *StringFuncFloatReducer {
	return &StringFuncFloatReducer{fn: fn}
}

func (r *StringFuncFloatReducer) Aggregate(points ...*StringPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &FloatPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *StringFuncFloatReducer) Emit() []FloatPoint {
	return []FloatPoint{*r.prev}
}

// StringReduceFloatSliceFunc is the function called by a StringPoint reducer.
type StringReduceFloatSliceFunc func(a []StringPoint) []FloatPoint

type StringSliceFuncFloatReducer struct {
	points []StringPoint
	fn     StringReduceFloatSliceFunc
}

func NewStringSliceFuncFloatReducer(fn StringReduceFloatSliceFunc) *StringSliceFuncFloatReducer {
	return &StringSliceFuncFloatReducer{fn: fn}
}

func (r *StringSliceFuncFloatReducer) Aggregate(points ...*StringPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]StringPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *StringSliceFuncFloatReducer) Emit() []FloatPoint {
	return r.fn(r.points)
}

// StringReduceIntegerFunc is the function called by a StringPoint reducer.
type StringReduceIntegerFunc func(prev *IntegerPoint, curr *StringPoint) (t int64, v int64, aux []interface{})

type StringFuncIntegerReducer struct {
	prev *IntegerPoint
	fn   StringReduceIntegerFunc
}

func NewStringFuncIntegerReducer(fn StringReduceIntegerFunc) *StringFuncIntegerReducer {
	return &StringFuncIntegerReducer{fn: fn}
}

func (r *StringFuncIntegerReducer) Aggregate(points ...*StringPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &IntegerPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *StringFuncIntegerReducer) Emit() []IntegerPoint {
	return []IntegerPoint{*r.prev}
}

// StringReduceIntegerSliceFunc is the function called by a StringPoint reducer.
type StringReduceIntegerSliceFunc func(a []StringPoint) []IntegerPoint

type StringSliceFuncIntegerReducer struct {
	points []StringPoint
	fn     StringReduceIntegerSliceFunc
}

func NewStringSliceFuncIntegerReducer(fn StringReduceIntegerSliceFunc) *StringSliceFuncIntegerReducer {
	return &StringSliceFuncIntegerReducer{fn: fn}
}

func (r *StringSliceFuncIntegerReducer) Aggregate(points ...*StringPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]StringPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *StringSliceFuncIntegerReducer) Emit() []IntegerPoint {
	return r.fn(r.points)
}

// StringReduceFunc is the function called by a StringPoint reducer.
type StringReduceFunc func(prev *StringPoint, curr *StringPoint) (t int64, v string, aux []interface{})

type StringFuncReducer struct {
	prev *StringPoint
	fn   StringReduceFunc
}

func NewStringFuncReducer(fn StringReduceFunc) *StringFuncReducer {
	return &StringFuncReducer{fn: fn}
}

func (r *StringFuncReducer) Aggregate(points ...*StringPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &StringPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *StringFuncReducer) Emit() []StringPoint {
	return []StringPoint{*r.prev}
}

// StringReduceSliceFunc is the function called by a StringPoint reducer.
type StringReduceSliceFunc func(a []StringPoint) []StringPoint

type StringSliceFuncReducer struct {
	points []StringPoint
	fn     StringReduceSliceFunc
}

func NewStringSliceFuncReducer(fn StringReduceSliceFunc) *StringSliceFuncReducer {
	return &StringSliceFuncReducer{fn: fn}
}

func (r *StringSliceFuncReducer) Aggregate(points ...*StringPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]StringPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *StringSliceFuncReducer) Emit() []StringPoint {
	return r.fn(r.points)
}

// StringReduceBooleanFunc is the function called by a StringPoint reducer.
type StringReduceBooleanFunc func(prev *BooleanPoint, curr *StringPoint) (t int64, v bool, aux []interface{})

type StringFuncBooleanReducer struct {
	prev *BooleanPoint
	fn   StringReduceBooleanFunc
}

func NewStringFuncBooleanReducer(fn StringReduceBooleanFunc) *StringFuncBooleanReducer {
	return &StringFuncBooleanReducer{fn: fn}
}

func (r *StringFuncBooleanReducer) Aggregate(points ...*StringPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &BooleanPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *StringFuncBooleanReducer) Emit() []BooleanPoint {
	return []BooleanPoint{*r.prev}
}

// StringReduceBooleanSliceFunc is the function called by a StringPoint reducer.
type StringReduceBooleanSliceFunc func(a []StringPoint) []BooleanPoint

type StringSliceFuncBooleanReducer struct {
	points []StringPoint
	fn     StringReduceBooleanSliceFunc
}

func NewStringSliceFuncBooleanReducer(fn StringReduceBooleanSliceFunc) *StringSliceFuncBooleanReducer {
	return &StringSliceFuncBooleanReducer{fn: fn}
}

func (r *StringSliceFuncBooleanReducer) Aggregate(points ...*StringPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]StringPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *StringSliceFuncBooleanReducer) Emit() []BooleanPoint {
	return r.fn(r.points)
}

// BooleanPointAggregator aggregates points to produce a single point.
type BooleanPointAggregator interface {
	Aggregate(points ...*BooleanPoint)
}

// BooleanPointEmitter produces a single point from an aggregate.
type BooleanPointEmitter interface {
	Emit() []BooleanPoint
}

// BooleanReduceFloatFunc is the function called by a BooleanPoint reducer.
type BooleanReduceFloatFunc func(prev *FloatPoint, curr *BooleanPoint) (t int64, v float64, aux []interface{})

type BooleanFuncFloatReducer struct {
	prev *FloatPoint
	fn   BooleanReduceFloatFunc
}

func NewBooleanFuncFloatReducer(fn BooleanReduceFloatFunc) *BooleanFuncFloatReducer {
	return &BooleanFuncFloatReducer{fn: fn}
}

func (r *BooleanFuncFloatReducer) Aggregate(points ...*BooleanPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &FloatPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *BooleanFuncFloatReducer) Emit() []FloatPoint {
	return []FloatPoint{*r.prev}
}

// BooleanReduceFloatSliceFunc is the function called by a BooleanPoint reducer.
type BooleanReduceFloatSliceFunc func(a []BooleanPoint) []FloatPoint

type BooleanSliceFuncFloatReducer struct {
	points []BooleanPoint
	fn     BooleanReduceFloatSliceFunc
}

func NewBooleanSliceFuncFloatReducer(fn BooleanReduceFloatSliceFunc) *BooleanSliceFuncFloatReducer {
	return &BooleanSliceFuncFloatReducer{fn: fn}
}

func (r *BooleanSliceFuncFloatReducer) Aggregate(points ...*BooleanPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]BooleanPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *BooleanSliceFuncFloatReducer) Emit() []FloatPoint {
	return r.fn(r.points)
}

// BooleanReduceIntegerFunc is the function called by a BooleanPoint reducer.
type BooleanReduceIntegerFunc func(prev *IntegerPoint, curr *BooleanPoint) (t int64, v int64, aux []interface{})

type BooleanFuncIntegerReducer struct {
	prev *IntegerPoint
	fn   BooleanReduceIntegerFunc
}

func NewBooleanFuncIntegerReducer(fn BooleanReduceIntegerFunc) *BooleanFuncIntegerReducer {
	return &BooleanFuncIntegerReducer{fn: fn}
}

func (r *BooleanFuncIntegerReducer) Aggregate(points ...*BooleanPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &IntegerPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *BooleanFuncIntegerReducer) Emit() []IntegerPoint {
	return []IntegerPoint{*r.prev}
}

// BooleanReduceIntegerSliceFunc is the function called by a BooleanPoint reducer.
type BooleanReduceIntegerSliceFunc func(a []BooleanPoint) []IntegerPoint

type BooleanSliceFuncIntegerReducer struct {
	points []BooleanPoint
	fn     BooleanReduceIntegerSliceFunc
}

func NewBooleanSliceFuncIntegerReducer(fn BooleanReduceIntegerSliceFunc) *BooleanSliceFuncIntegerReducer {
	return &BooleanSliceFuncIntegerReducer{fn: fn}
}

func (r *BooleanSliceFuncIntegerReducer) Aggregate(points ...*BooleanPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]BooleanPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *BooleanSliceFuncIntegerReducer) Emit() []IntegerPoint {
	return r.fn(r.points)
}

// BooleanReduceStringFunc is the function called by a BooleanPoint reducer.
type BooleanReduceStringFunc func(prev *StringPoint, curr *BooleanPoint) (t int64, v string, aux []interface{})

type BooleanFuncStringReducer struct {
	prev *StringPoint
	fn   BooleanReduceStringFunc
}

func NewBooleanFuncStringReducer(fn BooleanReduceStringFunc) *BooleanFuncStringReducer {
	return &BooleanFuncStringReducer{fn: fn}
}

func (r *BooleanFuncStringReducer) Aggregate(points ...*BooleanPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &StringPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *BooleanFuncStringReducer) Emit() []StringPoint {
	return []StringPoint{*r.prev}
}

// BooleanReduceStringSliceFunc is the function called by a BooleanPoint reducer.
type BooleanReduceStringSliceFunc func(a []BooleanPoint) []StringPoint

type BooleanSliceFuncStringReducer struct {
	points []BooleanPoint
	fn     BooleanReduceStringSliceFunc
}

func NewBooleanSliceFuncStringReducer(fn BooleanReduceStringSliceFunc) *BooleanSliceFuncStringReducer {
	return &BooleanSliceFuncStringReducer{fn: fn}
}

func (r *BooleanSliceFuncStringReducer) Aggregate(points ...*BooleanPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]BooleanPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *BooleanSliceFuncStringReducer) Emit() []StringPoint {
	return r.fn(r.points)
}

// BooleanReduceFunc is the function called by a BooleanPoint reducer.
type BooleanReduceFunc func(prev *BooleanPoint, curr *BooleanPoint) (t int64, v bool, aux []interface{})

type BooleanFuncReducer struct {
	prev *BooleanPoint
	fn   BooleanReduceFunc
}

func NewBooleanFuncReducer(fn BooleanReduceFunc) *BooleanFuncReducer {
	return &BooleanFuncReducer{fn: fn}
}

func (r *BooleanFuncReducer) Aggregate(points ...*BooleanPoint) {
	for _, p := range points {
		t, v, aux := r.fn(r.prev, p)
		if r.prev == nil {
			r.prev = &BooleanPoint{}
		}
		r.prev.Time = t
		r.prev.Value = v
		r.prev.Aux = aux
		if p.Aggregated > 1 {
			r.prev.Aggregated += p.Aggregated
		} else {
			r.prev.Aggregated++
		}
	}
}

func (r *BooleanFuncReducer) Emit() []BooleanPoint {
	return []BooleanPoint{*r.prev}
}

// BooleanReduceSliceFunc is the function called by a BooleanPoint reducer.
type BooleanReduceSliceFunc func(a []BooleanPoint) []BooleanPoint

type BooleanSliceFuncReducer struct {
	points []BooleanPoint
	fn     BooleanReduceSliceFunc
}

func NewBooleanSliceFuncReducer(fn BooleanReduceSliceFunc) *BooleanSliceFuncReducer {
	return &BooleanSliceFuncReducer{fn: fn}
}

func (r *BooleanSliceFuncReducer) Aggregate(points ...*BooleanPoint) {
	if len(points) == 1 {
		r.points = append(r.points, *points[0])
	} else if len(points) > 1 {
		if len(r.points)+len(points) <= cap(r.points) {
			for _, p := range points {
				r.points = append(r.points, *p)
			}
		} else {
			pts := make([]BooleanPoint, len(points))
			for i, p := range points {
				pts[i] = *p
			}
			r.points = append(r.points, pts...)
		}
	}
}

func (r *BooleanSliceFuncReducer) Emit() []BooleanPoint {
	return r.fn(r.points)
}
